{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"VGD Counterfactuals","text":"<p>VGD Counterfactuals is a Python library for the generation and visualization of counterfactual explanations for Graph Neural Networks (GNNs) based around the Visual Graph Datasets format.</p>"},{"location":"#what-are-counterfactuals","title":"What are Counterfactuals?","text":"<p>Counterfactuals are a method of explaining the predictions of complex machine learning models. For a certain prediction of a model, a counterfactual is an input element that is as similar as possible to the original input, but causes the largest possible deviation with respect to the original model output prediction.</p> <p>They are sort of \"counter examples\" for the behavior of a model and can help to understand the decision boundary of the model.</p> <p>The subject of this package are graph counterfactuals. They are generated by maximizing a customizable distance function in regards to the prediction output over all immediate neighbors of the original graph with respect to the allowed, domain-specific graph edit operations.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>\ud83c\udfaf Counterfactual Generation: Generate meaningful counterfactual explanations for GNN predictions</li> <li>\ud83d\udcca Easy Visualization: Built-in visualization capabilities for graph counterfactuals</li> <li>\ud83d\udd27 Flexible Framework: Customizable distance functions and neighborhood definitions</li> <li>\ud83e\uddea Domain Support: Special support for molecular graphs and other domains</li> <li>\ud83d\udcc8 VGD Integration: Seamless integration with Visual Graph Datasets</li> </ul>"},{"location":"#quick-navigation","title":"Quick Navigation","text":"<ul> <li>Installation - Get started with installing VGD Counterfactuals</li> <li>Get Started - Learn the basics with a simple example</li> <li>Tutorials - Dive deeper with comprehensive tutorials</li> </ul>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Python 3.9-3.12</li> <li>Visual Graph Datasets</li> <li>Compatible GNN models implementing the PredictGraph interface</li> </ul>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT License.</p>"},{"location":"get_started_core/","title":"Core Concepts","text":"<p>This section will introduce the core concepts of the <code>vgd_counterfactuals</code> library including the idea of \u2692\ufe0f counterfactual mining, \ud83d\uddfa\ufe0f graph domains and \ud83e\udde9 modularization.</p>"},{"location":"get_started_core/#counterfactual-mining","title":"\u2692\ufe0f Counterfactual Mining","text":""},{"location":"get_started_core/#what-are-counterfactuals","title":"What are Counterfactuals?","text":"<p>The core idea of counterfactuals\u2014independent of the data structure for now\u2014is to find elements which represent only small modifications regarding the original element, but cause a large deviation in the model's property prediction.</p> <p>Mathematically, this can be expressed as an optimization problem in which we want to simultaneously minimize the distance to the original element and maximize the difference to the original model prediction.</p>"},{"location":"get_started_core/#counterfactuals-in-other-domains","title":"Counterfactuals in other Domains","text":"<p>In other application domains, the previously described optimization problem is non-trivial to solve, as the space of possible modifications is extremely large and only a small subset of modifications leads to a valid element.</p> <p>In image processing, for example, pixels are represented as continuous values, and the space of possible modifications is infinite. Furthermore, a counterfactual modification should itself represent a valid image in the context of the underlying task to be meaningful. The modification of a handwritten digit should result in something that still looks like a digit, and\u2014crucially\u2014not a random noise pattern. Due to these constraints, these domains have to use more sophisticated methods to solve the non-trivial optimization problem of finding counterfactual samples. In image generation, for instance one possible approach would be to use gradient descent to iteratively modify the original image using a joint objective function that combines the distance to the original image and the difference in model prediction.</p> <p>In natural language processing, the space of possible modifications is at least discrete, but still very large since there is an extremely large number of words which could be inserted, removed or replaced at any position in a given text.</p>"},{"location":"get_started_core/#graph-counterfactuals","title":"Graph Counterfactuals","text":"<p>In contrast to these previously mentioned domains, graph data structures are much easier to handle. For one thing, graphs are discrete structures for which nodes and edges can either exist or not exist. Additionally, the vocabulary of different node and edge types is usually much smaller than with natural language, for instance.</p> <p>Therefore, one possible approach to generate counterfactuals\u2014infeasible in other domains\u2014is to generate all possible modifications of the original element, obtain the model's prediction for each of these modifications and then filter the modifications that lead to the largest deviation in the model's prediction. This is the basic approach taken by the <code>vgd_counterfactuals</code> library.</p>"},{"location":"get_started_core/#graph-domains","title":"\ud83d\uddfa\ufe0f Graph Domains","text":"<p>One important consideration for the generation of counterfactuals as described in the previous paragraph is that not all graphs are the same. The rules of what constitutes a valid graph structure\u2014and what modifications are allowed\u2014depend on the domain of where the graph originates from.</p> <p>For example, a molecular graph is a specific type of graph where nodes represent atoms and edges represent chemical bonds. In this case, there are very specific rules about which kinds of connections between atoms are allowed to constitute a valid molecule. Such a molecular graph needs completely different rules than an electrical circuit graph, where nodes represents connections and edges represent electrical components.</p> <p>Ultimately, the \ud83d\uddfa\ufe0f graph domain heavily influences how counterfactuals need to be generated, which is why they are a core concept of the <code>vgd_counterfactuals</code> library. Currently, the following domains are supported:</p> <ul> <li>Simple Color Graphs: For testing and demonstration purposes, where nodes are colored and edges connect nodes of different colors.</li> <li>Molecular Graphs: Using RDKit and SMILES notation, where nodes represent atoms and edges represent chemical bonds.</li> </ul>"},{"location":"get_started_core/#domain-representation","title":"\ud83d\udcdd Domain Representation","text":"<p>The <code>vgd_counterfactuals</code> library builds on top of the Visual Graph Datasets (VGD) library for it's graph representation. Consequently, it borrows the VGD concept of the \ud83d\udcdd domain representation. In the VGD library, each graph can be represented either generically as a graph structure with numeric node and edge features (ideal for machine learning applications) or in a domain-specific string format.</p> <p>An example of such a domain-specific string representation is the SMILES (Simplified Molecular Input Line Entry System) notation for molecular graphs, which is a widely used format to represent chemical structures as strings. The caffeine molecule, for example, can be represented as the SMILES string <code>CN1C=NC2=C1C(=O)N(C(=O)N2C)C</code>. This format is very compact and allows for easy sharing and storage of molecular graphs. More importantly, this exchange format is the foundation for many domain-specific tools such as the cheminformatics toolkit RDKit.</p>"},{"location":"get_started_core/#modularization","title":"\ud83e\udde9 Modularization","text":"<p>The goal of the <code>vgd_counterfactuals</code> library is to be customizable and to provide a modular framework for counterfactual generation. This means that individual components such as the model, the neighborhood function etc. can be swapped out and/or be replaced with custom implementations.</p> <p>The library is designed around the following core components which can be assembled to interact with each other:</p> <ul> <li>Neighborhood Function. Given the \ud83d\udcdd domain representation of a graph structure, this function should return the domain representations of it's immediate neighbors\u2014meaning all valid graphs with an edit distance of 1. The neighborhood function is domain-specific and will have to be implemented or customized for each new graph domain.</li> <li>Counterfactual Distance Function. Given an original graph and a modified graph, as well as the corresponding model predictions, this function is meant to return a numeric value that represents a measure of how different the two predictions are. This function will have to be supplied by the user as it depends on the specific circumstances. For instance, different distance functions will be necessary for regression tasks than for classification tasks. Another important consideration is that sometimes only one direction of the distance matters, e.g. increasing/decreasing the value in a regression task.</li> <li>Predictor Model. In principle, the library is meant to be agnostic to the specific model implementation, meaning that it should be possible to generate counterfactuals based on any model. However, to make a given model work with the library, one needs to supply an adapter function which accepts the domain representation of a graph, queries the model and returns the model's prediction.</li> </ul>"},{"location":"get_started_example/","title":"Introduction by Example","text":"<p>This section will provide a simple mock example of how to use the VGD Counterfactuals library to generate counterfactuals for a given graph representation.</p> Basic Example<pre><code>import tempfile\n\nfrom visual_graph_datasets.processing.molecules import MoleculeProcessing\n\nfrom vgd_counterfactuals.base import CounterfactualGenerator\nfrom vgd_counterfactuals.testing import MockModel\nfrom vgd_counterfactuals.generate.molecules import get_neighborhood\n\nprocessing = MoleculeProcessing() \nmodel = MockModel()\n\ngenerator = CounterfactualGenerator(\n    processing=processing,  # (1)\n    model=model,  # (2)\n    neighborhood_func=get_neighborhood,  # (3)\n    distance_func=lambda orig, mod: abs(orig - mod),  # (4)\n    predict_func=lambda model, graphs: model.predict_graphs(graphs),  # (5) \n)\n\nwith tempfile.TemporaryDirectory() as path: # (6)\n\n    # The \"generate\" function will create all the possible neighbors of the\n    # given \"original\" element, then query the model for to predict the\n    # output for each of them, and sort them by their distance to the original.\n    # The top k elements will be turned into a temporary visual graph dataset\n    # within the given folder \"path\".\n    index_data_map = generator.generate(\n        original='CCCCCC',\n        # Path to the folder into which to save the vgd element files\n        path=path,\n        # The number of counterfactuals to be returned.\n        # Elements will be sorted by their distance.\n        k_results=10,\n    )\n\n    # The keys of the resulting dict are the integer indices and the values\n    # are dicts themselves which describe the corresponding vgd elements.\n    # These dicts contain for example the absolute path to the PNG file,\n    # the full graph representation and additional metadata.\n    print(f'generated {len(index_data_map)} counterfactuals:')\n    for index, data in index_data_map.items():\n        print(f' * {data[\"metadata\"][\"name\"]} '\n              f' - distance: {data[\"metadata\"][\"distance\"]:.2f}')\n</code></pre> <ol> <li> <p>The domain specific <code>Processing</code> instance from the VGD libarary which implements the conversion     of the string domain representation into the graph dictionary format. This graph dictionary format      is then what is usually passed to the actual model for the prediction.</p> <p>In this example, we use the <code>MoleculeProcessing</code> class which is able to take a SMILES string  representation of a molecule and convert it into a graph dictionary format.</p> </li> <li> <p>The model which will be used to obtain the predictions for the original and the modified graphs.     This model may in principle by any kind of model.</p> </li> <li> <p>The neighborhood function which defines how to find similar and valid graphs in the domain.      This function will be called with the original graph and should return a list of similar graphs which are exactly one modification away from the original graph\u2014what exactly one modification means, however, relies on the specific domain.</p> <p>A valid neighborhood function <code>get_neighborhood(value: str) -&gt; List[str]</code> accepts a single string domain representation and returns a list of string which are again valid domain representations.</p> </li> <li> <p>The distance function which defines how to measure the difference between the predictions      of the original and modified graphs. </p> <p>A valid distance function <code>distance_func(original: float | np.ndarray, modified: float | np.ndarray) -&gt; float</code> accepts the predictions of the original and modified graphs and returns a numeric value which quantifies the difference between them. Note that the predictions can either be single values (regression) or vectors (classification) depending on the model used.</p> </li> <li> <p>The predict function which defines how to obtain the predictions for a given list of graphs.      This function will be called with the model and a list of graph dictionaries and should return a list of predictions for each graph.</p> <p>A valid predict function <code>predict_func(model: Any, graphs: List[Dict]) -&gt; List[float | np.ndarray]</code> accepts the model and a list of graph dictionaries and returns a list of predictions for each graph. Note that the graphs which are passed here are the graph dictionaries not the string representations. Also note, that whatever kind of data structure (float, np array, etc) the model returns here as the result of the prediction will be the arguments passed to the distance function.</p> </li> <li> <p>For the sake of the example we will create a temporary directory to store the generated files      in. In a real application, it might make sense to store the results to a more permanent location.</p> <p>In essence the counterfactual generation will store the counterfactuals as a visual graph dataset which consists of 2 files per graph: A visualization PNG and a JSON file containing the graph  representation and metadata.</p> </li> </ol>"},{"location":"get_started_example/#the-counterfactualgenerator-class","title":"The <code>CounterfactualGenerator</code> Class","text":"<p>The <code>CounterfactualGenerator</code> class is the central component of the library to orchestrate the counterfactual generation process. An instance of this class will have to be initialized once for the generation of counterfactuals for a specific domain and based on a specific model.</p> <p>The counterfactual generator requires a series of arguments to be passed to its constructor which define the various steps of the generation process, such as how the domain representations are processed into graph structures, which model to use for the predictions, how to find similar graphs in the domain and how to measure the difference between the predictions of the original and modified graphs.</p>"},{"location":"get_started_example/#the-generate-method","title":"The <code>generate</code> Method","text":"<p>The generate method of the counterfactual generator will then actually generate the counterfactuals for an original graph\u2014given in its string domain representation. The method will return the <code>k_results</code> top ranked counterfactuals based on the distance function defined in the constructor.</p> <p>Internally, the method will do the following:</p> <ol> <li> <p>Convert the original string representatio into a graph and query the model to obtain the original prediction.</p> </li> <li> <p>Use the neighborhood function to find all valid modifications of the original graph.</p> </li> <li> <p>Query the model for the predictions of all modified graphs.</p> </li> <li> <p>Calculate the distance between the original prediction and each modified prediction using the distance function.</p> </li> <li> <p>Sort the modified graphs by their distance to the original graph.</p> </li> <li> <p>Return the top <code>k_results</code> modified graphs as a dictionary mapping indices to graph data.</p> </li> </ol> <p>Specifically, the return value of the <code>generate</code> method is a dictionary in the visual graph dataset format. Moreover, the visual graph dataset will also directly be stored persistently to the given <code>path</code> directory, including the PNG visualizations and the JSON graph representations.</p>"},{"location":"installation/","title":"Installation","text":"<p>This guide will help you install VGD Counterfactuals and its dependencies.</p>"},{"location":"installation/#requirements","title":"Requirements","text":"<p>VGD Counterfactuals requires Python 3.9 or later (up to Python 3.12). Make sure you have a compatible Python version installed:</p> <pre><code>python --version\n</code></pre>"},{"location":"installation/#installation-methods","title":"Installation Methods","text":""},{"location":"installation/#method-1-install-from-pypi-stable-release","title":"Method 1: Install from PyPI (Stable Release)","text":"<p>You can install the stable release of VGD Counterfactuals directly from PyPI:</p> <pre><code>pip install vgd_counterfactuals\n</code></pre>"},{"location":"installation/#method-2-install-from-source-recommended","title":"Method 2: Install from Source (Recommended)","text":"<p>1. Clone the repository: <pre><code>git clone https://github.com/the16thpythonist/vgd_counterfactuals.git\ncd vgd_counterfactuals\n</code></pre></p> <p>2. Create a virtual environment (recommended): <pre><code>python -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\n</code></pre></p> <p>3. Install the package: <pre><code>pip install -e .\n</code></pre></p>"},{"location":"installation/#verify-installation","title":"Verify Installation","text":"<p>After installation, verify that VGD Counterfactuals is properly installed:</p> <pre><code>python -m vgd_counterfactuals.cli --version\npython -m vgd_counterfactuals.cli --help\n</code></pre> <p>You should see the version information and help text.</p>"},{"location":"installation/#next-steps","title":"Next Steps","text":"<p>Once you have VGD Counterfactuals installed, head over to the Get Started guide to learn how to use the library with a simple example.</p>"},{"location":"tutorials/","title":"Tutorials","text":"<p>Welcome to the VGD Counterfactuals tutorials. These guides cover various features of the library, from basic usage to advanced customization.</p>"},{"location":"tutorials/#overview","title":"Overview","text":"<p>These tutorials are now split into focused documents:</p> <ol> <li>Using \ud83d\udc69\u200d\ud83c\udfeb Megan - Generate counterfactuals for a Multi-Explanation Graph Attention Network (MEGAN)</li> </ol>"},{"location":"tutorials_megan/","title":"Using MEGAN","text":"<p>This section will showcase a simple application example of how to use the <code>vgd_counterfactuals</code> library with the \ud83d\udc69\u200d\ud83c\udfeb Multi-Explanation Graph Attention Network (MEGAN) model to generate counterfactuals on top of the attributional explanations provided by MEGAN.</p>"},{"location":"tutorials_megan/#pre-requisites","title":"Pre-requisites","text":"<p>Additional Packages. This example assumes that you have the following libraries installed, in addition to the <code>vgd_counterfactuals</code> library:</p> <pre><code>pip install graph_attention_student\n</code></pre> <p>Pre-trained Model. This example also assumes that you have access to a pre-trained MEGAN model in the form of a checkpoint file. It's assumed that the model was trained on graph structured obtained through <code>MoleculeProcessing</code> class which is loaded from a separate <code>process.py</code> module. If that is not the case\u2014e.g. different domain\u2014the corresponding components of the example will have to be adapted accordingly.</p>"},{"location":"tutorials_megan/#example","title":"Example","text":"MEGAN Counterfactuals<pre><code>import pathlib\nimport tempfile\nfrom typing import List, Dict\n\nimport matplotlib.pyplot as plt\nfrom rich.pretty import pprint\nfrom graph_attention_student.torch.megan import Megan\nfrom visual_graph_datasets.util import dynamic_import\nfrom vgd_counterfactuals.base import CounterfactualGenerator\nfrom vgd_counterfactuals.generate.molecules import get_neighborhood\n\nPATH = pathlib.Path(__file__).parent.parent\n\n# ~ loading the pre-trained model &amp; processing\nCHECKPOINT_PATH = PATH / 'assets' / 'megan.ckpt'  # Replace with your path\nPROCESSING_PATH = PATH / 'assets' / 'process.py'  # Replace with your path\n\nmodel: Megan = Megan.load(CHECKPOINT_PATH) \nprocessing = dynamic_import(PROCESSING_PATH, 'processing').processing\n\n# ~ defining the necessary functions\n\ndef predict_func(model: Megan, graphs: List[dict]):\n    results: List[dict] = model.forward_graphs(graphs)  # (1)\n    return results\n\ndef distance_func(org: dict, mod: dict):\n    distance: float = abs(org['graph_output'] - mod['graph_output'])  # (2)\n    return distance\n\n# ~ setting up the counterfactual generator\n\ngenerator = CounterfactualGenerator(\n    processing=processing,\n    model=model,\n    neighborhood_func=get_neighborhood,  # (3)\n    distance_func=distance_func,\n    predict_func=predict_func\n)\n\n# ~ generating counterfactuals\n\nwith tempfile.TemporaryDirectory() as temp_dir:\n\n    # Generate counterfactuals for a specific molecule\n    index_data_dict: Dict[int, dict] = generator.generate(\n        original='CCO',                 # Ethanol\n        path=tempfile.gettempdir(),     # Temporary directory for results\n        k_results=5                     # Generate 5 counterfactuals\n    )\n\n    for index, data in index_data_dict.items():\n\n        image_path = data['image_path']\n\n        graph = data['metadata']['graph']       # Full graph dictionary\n        pprint(graph)\n\n        plt.imshow(plt.imread(image_path))\n        plt.title(f\"Counterfactual {index}\")\n        plt.axis('off')\n        plt.show()\n        break\n</code></pre> <ol> <li> <p><code>Megan</code> model class offers the <code>forward_graphs</code> method which accepts a list of graph      dictionaries as an input and returns the corresponding list of model predictions. However, note that these model predictions are again dictionary structures which contain multiple fields\u2014not just the actual prediction, but also the attributional explanation masks and the graph embedding vector, for example. Returning this list of of dictionaries for the <code>predict_func</code> means that these dicts will be the input types for the distance function later on.</p> </li> <li> <p>Since the model prediction results are dictionaries, the input type of the distance function      is also dictionaries. For <code>Megan</code> models the actual model prediction (in this case regression value) is stored in the <code>graph_output</code> field of the dictionary.</p> <p>Note that using a dictionary as the model prediction and consequently as the input type for the distance function allows us more flexibility in the definition of the counterfactual distance. For instance, one could define a distance function which also takes the explanations into account and not just the model prediction.</p> </li> <li> <p>In this case we can use the molecule based neighborhood function which is pre-defined in      the library. This function will attempt to do all possible single-edit atom additions, removals and bond additions and removals based on the chemical valence rules using the RDKit library.</p> </li> </ol>"}]}